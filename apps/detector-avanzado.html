<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StatForensics Lab v3 ‚Äî An√°lisis Forense de Integridad de Datos</title>
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script src="https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6"></script>
    <style>
        :root {
            --primary: #1a2332;
            --accent: #2980b9;
            --accent-light: #3498db;
            --danger: #c0392b;
            --danger-light: #e74c3c;
            --warning: #d68910;
            --warning-light: #f39c12;
            --success: #1e8449;
            --success-light: #27ae60;
            --neutral: #5d6d7e;
            --bg: #f4f6f9;
            --card: #ffffff;
            --text: #2c3e50;
            --text-secondary: #7f8c8d;
            --border: #dfe6e9;
            --shadow: 0 1px 4px rgba(0,0,0,0.06);
            --shadow-hover: 0 4px 12px rgba(0,0,0,0.1);
            --radius: 8px;
            --mono: 'SF Mono', 'Fira Code', 'Consolas', monospace;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.65;
            font-size: 14px;
        }

        /* HEADER */
        .app-header {
            background: var(--primary);
            color: #ecf0f1;
            padding: 1.8rem 2rem;
            position: relative;
        }
        .app-header h1 {
            font-size: 1.5rem;
            font-weight: 700;
            letter-spacing: -0.02em;
        }
        .app-header .tagline {
            font-size: 0.88rem;
            opacity: 0.7;
            margin-top: 0.2rem;
        }
        .version {
            position: absolute;
            top: 1.8rem;
            right: 2rem;
            background: rgba(255,255,255,0.1);
            padding: 3px 12px;
            border-radius: 12px;
            font-size: 0.75rem;
        }

        .container {
            max-width: 1320px;
            margin: 0 auto;
            padding: 1.5rem;
        }

        /* PANELS */
        .panel {
            background: var(--card);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            margin-bottom: 1.2rem;
            overflow: hidden;
        }
        .panel-header {
            padding: 0.9rem 1.2rem;
            border-bottom: 1px solid var(--border);
            background: #fafbfc;
            font-weight: 700;
            font-size: 0.95rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .panel-body { padding: 1.2rem; }

        /* FORM */
        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1rem;
        }
        .form-group { display: flex; flex-direction: column; }
        .form-group label {
            font-size: 0.78rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 3px;
            text-transform: uppercase;
            letter-spacing: 0.04em;
        }
        .form-group input,
        .form-group select {
            padding: 7px 10px;
            border: 1px solid var(--border);
            border-radius: 5px;
            font-size: 0.88rem;
            transition: border-color 0.2s;
        }
        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(41,128,185,0.12);
        }
        .form-group .hint {
            font-size: 0.72rem;
            color: var(--text-secondary);
            margin-top: 2px;
        }

        textarea {
            width: 100%;
            min-height: 80px;
            padding: 10px 12px;
            border: 1px solid var(--border);
            border-radius: 5px;
            font-family: var(--mono);
            font-size: 0.82rem;
            resize: vertical;
            line-height: 1.5;
        }
        textarea:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(41,128,185,0.12);
        }

        /* BUTTONS */
        .btn-row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 1rem;
        }
        .btn {
            padding: 9px 18px;
            border: none;
            border-radius: 5px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            color: white;
        }
        .btn:hover { transform: translateY(-1px); box-shadow: var(--shadow-hover); }
        .btn:active { transform: translateY(0); }
        .btn-accent { background: var(--accent); }
        .btn-success { background: var(--success); }
        .btn-danger { background: var(--danger); }
        .btn-warning { background: var(--warning); }
        .btn-ghost {
            background: transparent;
            color: var(--text);
            border: 1px solid var(--border);
        }
        .btn-ghost:hover { background: #f0f0f0; }

        /* SCORE */
        .score-band {
            display: none;
            padding: 1.2rem 1.5rem;
            border-radius: var(--radius);
            margin-bottom: 1.2rem;
            box-shadow: var(--shadow);
        }
        .score-band .score-row {
            display: flex;
            align-items: center;
            gap: 1.5rem;
        }
        .score-circle {
            width: 80px; height: 80px;
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-size: 1.6rem; font-weight: 800;
            color: white;
            flex-shrink: 0;
        }
        .score-text h2 { font-size: 1.1rem; margin-bottom: 0.2rem; }
        .score-text p { font-size: 0.85rem; opacity: 0.85; }
        .level-low { background: #eafaf1; border: 1px solid #a9dfbf; }
        .level-low .score-circle { background: var(--success); }
        .level-mid { background: #fef9e7; border: 1px solid #f9e79f; }
        .level-mid .score-circle { background: var(--warning); }
        .level-high { background: #fdedec; border: 1px solid #f5b7b1; }
        .level-high .score-circle { background: var(--danger); }

        /* PROGRESS / SIMULATION */
        .sim-bar {
            display: none;
            margin-bottom: 1.2rem;
        }
        .sim-bar .bar-track {
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            overflow: hidden;
        }
        .sim-bar .bar-fill {
            height: 100%;
            background: var(--accent);
            border-radius: 3px;
            transition: width 0.1s;
            width: 0%;
        }
        .sim-bar .bar-label {
            font-size: 0.78rem;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        /* DASHBOARD */
        .dashboard {
            display: none;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1.2rem;
        }
        @media (max-width: 860px) {
            .dashboard { grid-template-columns: 1fr; }
        }

        .card {
            background: var(--card);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            overflow: hidden;
            transition: box-shadow 0.2s;
        }
        .card:hover { box-shadow: var(--shadow-hover); }
        .card-head {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 14px;
            background: #fafbfc;
            border-bottom: 1px solid var(--border);
        }
        .card-head h3 {
            font-size: 0.88rem;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .badge {
            font-size: 0.68rem;
            padding: 2px 9px;
            border-radius: 10px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }
        .bg-pass { background: #d5f5e3; color: #1e8449; }
        .bg-warn { background: #fef9e7; color: #b7950b; }
        .bg-fail { background: #fadbd8; color: #922b21; }
        .bg-info { background: #d6eaf8; color: #21618c; }

        .card-content { padding: 14px; }
        .card-content .rationale {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 8px;
            line-height: 1.5;
            border-left: 3px solid var(--border);
            padding-left: 10px;
        }
        .plot-area {
            margin: 8px 0;
            overflow-x: auto;
        }
        .plot-area figure { margin: 0; }

        .finding {
            margin-top: 10px;
            padding: 10px 12px;
            border-radius: 6px;
            font-size: 0.82rem;
            line-height: 1.55;
        }
        .finding-ok { background: #eafaf1; border-left: 3px solid var(--success-light); }
        .finding-warn { background: #fef9e7; border-left: 3px solid var(--warning-light); }
        .finding-fail { background: #fdedec; border-left: 3px solid var(--danger-light); }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
            font-size: 0.82rem;
            border-bottom: 1px solid #f5f5f5;
        }
        .stat-row:last-child { border-bottom: none; }
        .stat-key { color: var(--text-secondary); }
        .stat-val { font-family: var(--mono); font-weight: 600; }

        /* REPORT */
        .report-panel { display: none; }
        .report-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.83rem;
            margin: 1rem 0;
        }
        .report-table th,
        .report-table td {
            padding: 8px 12px;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }
        .report-table th {
            background: #f8f9fa;
            font-weight: 700;
            font-size: 0.78rem;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            color: var(--text-secondary);
        }
        .report-table tfoot td {
            font-weight: 700;
            border-top: 2px solid var(--text);
        }

        /* METHODOLOGY */
        .method-toggle {
            width: 100%;
            text-align: left;
            padding: 12px 16px;
            background: #fafbfc;
            border: none;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: var(--text);
        }
        .method-toggle:hover { background: #f0f1f3; transform: none; box-shadow: none; }
        .method-body {
            display: none;
            padding: 1.2rem 1.5rem;
            font-size: 0.83rem;
            line-height: 1.75;
        }
        .method-body.open { display: block; }
        .method-body h4 {
            margin: 0.8rem 0 0.2rem;
            color: var(--accent);
            font-size: 0.9rem;
        }
        .method-body p { margin-bottom: 0.4rem; }
        .method-body code {
            background: #f0f0f0;
            padding: 1px 5px;
            border-radius: 3px;
            font-size: 0.8rem;
        }
        .method-body .ref-list {
            margin-top: 0.5rem;
            padding-left: 1.2rem;
            font-size: 0.8rem;
        }

        .footer {
            text-align: center;
            padding: 2rem;
            font-size: 0.78rem;
            color: var(--text-secondary);
        }
        .footer a { color: var(--accent); text-decoration: none; }
        .footer a:hover { text-decoration: underline; }

        /* PRINT */
        @media print {
            .app-header { background: white !important; color: black !important; border-bottom: 2px solid black; }
            .version { display: none; }
            .panel:has(.btn-row), .sim-bar, .footer { display: none !important; }
            .score-band, .dashboard, .report-panel { display: block !important; }
            .dashboard { display: grid !important; }
            .card, .panel { box-shadow: none !important; border: 1px solid #ccc; break-inside: avoid; }
            body { background: white; font-size: 11px; }
        }
    </style>
</head>
<body>

<header class="app-header">
    <h1>üî¨ StatForensics Lab</h1>
    <p class="tagline">Evaluaci√≥n de Integridad de Datos por M√©todos Estad√≠sticos con Inferencia por Remuestreo</p>
    <span class="version">v3.0 ¬∑ Monte Carlo</span>
</header>

<div class="container">

    <!-- CONFIG -->
    <div class="panel">
        <div class="panel-header">‚öôÔ∏è Configuraci√≥n del An√°lisis</div>
        <div class="panel-body">

            <div class="form-grid">
                <div class="form-group">
                    <label>Variable</label>
                    <select id="varSelect" onchange="applyPreset()">
                        <option value="custom">‚Äî Personalizada ‚Äî</option>
                        <option value="hb" selected>Hemoglobina (g/L)</option>
                        <option value="glucose">Glucemia (mg/dL)</option>
                        <option value="chol">Colesterol Total (mg/dL)</option>
                        <option value="sbp">Presi√≥n Sist√≥lica (mmHg)</option>
                        <option value="hr">Frecuencia Card√≠aca (lpm)</option>
                        <option value="temp">Temperatura (¬∞C)</option>
                        <option value="wbc">Leucocitos (√ó10¬≥/¬µL)</option>
                        <option value="plt">Plaquetas (√ó10¬≥/¬µL)</option>
                        <option value="crea">Creatinina (mg/dL)</option>
                        <option value="bmi">IMC (kg/m¬≤)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Media poblacional (Œº)</label>
                    <input type="number" id="popMean" step="any">
                    <span class="hint">Conocida o de referencia</span>
                </div>
                <div class="form-group">
                    <label>DE poblacional (œÉ)</label>
                    <input type="number" id="popSD" step="any">
                    <span class="hint">Conocida o de referencia</span>
                </div>
                <div class="form-group">
                    <label>Decimales de medici√≥n</label>
                    <input type="number" id="decimals" min="0" max="4" value="0">
                    <span class="hint">Resoluci√≥n del instrumento</span>
                </div>
                <div class="form-group">
                    <label>Simulaciones Monte Carlo</label>
                    <select id="nSim">
                        <option value="2000">2 000 (r√°pido)</option>
                        <option value="5000" selected>5 000 (est√°ndar)</option>
                        <option value="10000">10 000 (preciso)</option>
                    </select>
                </div>
            </div>

            <div style="margin-top: 1rem;">
                <div class="form-group">
                    <label>Datos observados</label>
                    <textarea id="dataInput" placeholder="Pegue aqu√≠ los valores separados por comas, espacios, tabuladores o saltos de l√≠nea.&#10;Ejemplo: 120, 134, 156, 142, 138, 145, 129, 151"></textarea>
                </div>
            </div>

            <div class="btn-row">
                <button class="btn btn-accent" onclick="runFullAnalysis()">üî¨ Ejecutar An√°lisis Completo</button>
                <button class="btn btn-success" onclick="generateData('real')">Simular Biol√≥gicos</button>
                <button class="btn btn-danger" onclick="generateData('fake_round')">Simular Falsos: Redondeo</button>
                <button class="btn btn-warning" onclick="generateData('fake_alt')">Simular Falsos: Alternaci√≥n</button>
                <button class="btn btn-danger" onclick="generateData('fake_narrow')">Simular Falsos: Rango Estrecho</button>
                <button class="btn btn-ghost" onclick="clearAll()">Limpiar</button>
            </div>
        </div>
    </div>

    <!-- SIMULATION PROGRESS -->
    <div class="sim-bar" id="simBar">
        <div class="bar-track"><div class="bar-fill" id="simFill"></div></div>
        <div class="bar-label" id="simLabel">Simulando...</div>
    </div>

    <!-- SCORE -->
    <div class="score-band" id="scoreBand">
        <div class="score-row">
            <div class="score-circle" id="scoreCircle"></div>
            <div class="score-text">
                <h2 id="scoreTitle"></h2>
                <p id="scoreDesc"></p>
            </div>
        </div>
    </div>

    <!-- DASHBOARD -->
    <div class="dashboard" id="dashboard">

        <!-- T1: Distribuci√≥n -->
        <div class="card" id="card1">
            <div class="card-head">
                <h3>üìä Distribuci√≥n Observada vs. Esperada</h3>
                <span class="badge" id="b1"></span>
            </div>
            <div class="card-content">
                <div class="rationale">Se superpone el histograma observado con la densidad normal esperada (Œº, œÉ proporcionados). Se eval√∫a mediante test de Kolmogorov-Smirnov con p-valor por Monte Carlo.</div>
                <div class="plot-area" id="p1"></div>
                <div id="s1"></div>
                <div id="f1"></div>
            </div>
        </div>

        <!-- T2: D√≠gito Terminal -->
        <div class="card" id="card2">
            <div class="card-head">
                <h3>üî¢ Uniformidad del D√≠gito Terminal</h3>
                <span class="badge" id="b2"></span>
            </div>
            <div class="card-content">
                <div class="rationale">En mediciones con resoluci√≥n fija, el √∫ltimo d√≠gito significativo se distribuye U(0,9). Los humanos sobrerrepresentan 0 y 5. Se eval√∫a con œá¬≤ y p-valor exacto por permutaci√≥n.</div>
                <div class="plot-area" id="p2"></div>
                <div id="s2"></div>
                <div id="f2"></div>
            </div>
        </div>

        <!-- T3: Benford -->
        <div class="card" id="card3">
            <div class="card-head">
                <h3>üìê Ley de Benford (Primer D√≠gito)</h3>
                <span class="badge" id="b3"></span>
            </div>
            <div class="card-content">
                <div class="rationale">El primer d√≠gito significativo de datos naturales sigue P(d) = log‚ÇÅ‚ÇÄ(1+1/d). Se cuantifica con MAD de Nigrini y œá¬≤ con p-valor por Monte Carlo contra la distribuci√≥n de referencia simulada.</div>
                <div class="plot-area" id="p3"></div>
                <div id="s3"></div>
                <div id="f3"></div>
            </div>
        </div>

        <!-- T4: Rachas -->
        <div class="card" id="card4">
            <div class="card-head">
                <h3>üèÉ Test de Rachas (Wald-Wolfowitz)</h3>
                <span class="badge" id="b4"></span>
            </div>
            <div class="card-content">
                <div class="rationale">Cuenta secuencias consecutivas por encima/debajo de la mediana. Los humanos alternan excesivamente, produciendo m√°s rachas de las esperadas. P-valor por simulaci√≥n Monte Carlo.</div>
                <div class="plot-area" id="p4"></div>
                <div id="s4"></div>
                <div id="f4"></div>
            </div>
        </div>

        <!-- T5: Autocorrelaci√≥n -->
        <div class="card" id="card5">
            <div class="card-head">
                <h3>üìà Autocorrelaci√≥n Serial (Lag 1-5)</h3>
                <span class="badge" id="b5"></span>
            </div>
            <div class="card-content">
                <div class="rationale">En datos independientes, r(lag) ‚âà 0. Los humanos producen autocorrelaci√≥n negativa en lag-1 al evitar valores similares consecutivos. Bandas de confianza al 95% por remuestreo.</div>
                <div class="plot-area" id="p5"></div>
                <div id="s5"></div>
                <div id="f5"></div>
            </div>
        </div>

        <!-- T6: Entrop√≠a -->
        <div class="card" id="card6">
            <div class="card-head">
                <h3>üåÄ Entrop√≠a de Shannon (D√≠gitos Terminales)</h3>
                <span class="badge" id="b6"></span>
            </div>
            <div class="card-content">
                <div class="rationale">H = -Œ£ p·µ¢ log‚ÇÇ(p·µ¢) mide la diversidad de d√≠gitos. Para uniformidad perfecta, H = log‚ÇÇ(10) ‚âà 3.322 bits. Valores bajos indican concentraci√≥n en pocos d√≠gitos. Intervalo de referencia por Monte Carlo.</div>
                <div class="plot-area" id="p6"></div>
                <div id="s6"></div>
                <div id="f6"></div>
            </div>
        </div>

        <!-- T7: Duplicados -->
        <div class="card" id="card7">
            <div class="card-head">
                <h3>‚ôä Tasa de Duplicados</h3>
                <span class="badge" id="b7"></span>
            </div>
            <div class="card-content">
                <div class="rationale">Se compara la proporci√≥n de valores √∫nicos contra lo esperado por simulaci√≥n de N(Œº,œÉ) redondeada a la resoluci√≥n del instrumento. Exceso o d√©ficit de duplicados son ambos sospechosos.</div>
                <div class="plot-area" id="p7"></div>
                <div id="s7"></div>
                <div id="f7"></div>
            </div>
        </div>

        <!-- T8: Forma -->
        <div class="card" id="card8">
            <div class="card-head">
                <h3>‚öñÔ∏è Curtosis y Asimetr√≠a (QQ-Plot)</h3>
                <span class="badge" id="b8"></span>
            </div>
            <div class="card-content">
                <div class="rationale">Datos fabricados uniformemente tienen curtosis negativa (platoc√∫rticos). Se construye QQ-Plot contra N(Œº,œÉ) y se eval√∫an los momentos con intervalos de referencia por remuestreo.</div>
                <div class="plot-area" id="p8"></div>
                <div id="s8"></div>
                <div id="f8"></div>
            </div>
        </div>

        <!-- T9: Diferencias Consecutivas -->
        <div class="card" id="card9">
            <div class="card-head">
                <h3>üìè Diferencias Consecutivas (MSSD)</h3>
                <span class="badge" id="b9"></span>
            </div>
            <div class="card-content">
                <div class="rationale">El MSSD (Mean Square of Successive Differences) de Von Neumann es sensible a no aleatoriedad serial. Se calcula el ratio MSSD/Varianza; bajo aleatoriedad, ‚âà 2.0. P-valor por Monte Carlo.</div>
                <div class="plot-area" id="p9"></div>
                <div id="s9"></div>
                <div id="f9"></div>
            </div>
        </div>

        <!-- T10: Resumen -->
        <div class="card" id="card10">
            <div class="card-head">
                <h3>üìã Resumen Descriptivo</h3>
                <span class="badge bg-info" id="b10">INFO</span>
            </div>
            <div class="card-content">
                <div id="summaryContent"></div>
            </div>
        </div>
    </div>

    <!-- REPORT -->
    <div class="panel report-panel" id="reportPanel">
        <div class="panel-header">üìÑ Informe de Integridad de Datos</div>
        <div class="panel-body">
            <p style="font-size:0.82rem; color:var(--text-secondary); margin-bottom:0.5rem;">
                Fecha: <span id="rptDate"></span> ¬∑ An√°lisis no supervisado ¬∑ <span id="rptNSim"></span> simulaciones Monte Carlo
            </p>
            <div id="reportBody"></div>
            <div style="margin-top:1rem; padding:12px; background:#f8f9fa; border-radius:6px; font-size:0.8rem; color:var(--text-secondary); line-height:1.6;">
                <strong>Nota interpretativa:</strong> Este informe presenta hallazgos estad√≠sticos objetivos. Una puntuaci√≥n alta indica que los datos observados difieren del comportamiento esperado bajo muestreo aleatorio de la distribuci√≥n de referencia. Esto puede deberse a fabricaci√≥n, errores de transcripci√≥n, sesgos del instrumento de medici√≥n, poblaci√≥n no est√°ndar u otras causas leg√≠timas. Los hallazgos deben interpretarse en contexto y no constituyen por s√≠ solos una acusaci√≥n de fraude.
            </div>
            <div class="btn-row" style="justify-content:center; margin-top:1rem;">
                <button class="btn btn-accent" onclick="window.print()">üñ®Ô∏è Imprimir / Guardar como PDF</button>
            </div>
        </div>
    </div>

    <!-- METHODOLOGY -->
    <div class="panel">
        <button class="method-toggle" onclick="toggleMethod()">
            üìö Fundamento Metodol√≥gico y Referencias
            <span id="mArrow">‚ñº</span>
        </button>
        <div class="method-body" id="mBody">
            <h4>Filosof√≠a del An√°lisis</h4>
            <p>Esta herramienta implementa un enfoque de <em>inferencia por simulaci√≥n</em>: para cada estad√≠stico forense calculado sobre los datos observados, se genera una distribuci√≥n de referencia emp√≠rica mediante Monte Carlo. Se simulan <code>B</code> muestras del mismo tama√±o <code>n</code> desde N(Œº, œÉ) (redondeadas a la resoluci√≥n del instrumento), y se calcula el mismo estad√≠stico en cada muestra simulada. El p-valor emp√≠rico es la proporci√≥n de simulaciones que producen un estad√≠stico tan extremo o m√°s que el observado.</p>

            <h4>Prueba 1 ‚Äî Distribuci√≥n (Kolmogorov-Smirnov)</h4>
            <p>D = sup|F‚Çô(x) - F‚ÇÄ(x)|, donde F‚ÇÄ es la CDF de la distribuci√≥n de referencia. El p-valor se obtiene por Monte Carlo ya que F‚ÇÄ puede no ser exactamente continua tras el redondeo.</p>

            <h4>Prueba 2 ‚Äî D√≠gito Terminal (œá¬≤ de uniformidad)</h4>
            <p>œá¬≤ = Œ£(O·µ¢ - E·µ¢)¬≤/E·µ¢ con gl=9 y E·µ¢ = n/10. El p-valor param√©trico asume gl=9; el p-valor Monte Carlo simula muestras reales redondeadas y calcula œá¬≤ en cada una para verificar que la distribuci√≥n de referencia real (no te√≥rica) sea efectivamente uniforme.</p>

            <h4>Prueba 3 ‚Äî Ley de Benford</h4>
            <p>MAD = (1/9)Œ£|p·µ¢ - b·µ¢| donde b·µ¢ = log‚ÇÅ‚ÇÄ(1+1/i). Clasificaci√≥n de Nigrini: MAD ‚â§ 0.006 (conforme), ‚â§ 0.012 (aceptable), ‚â§ 0.015 (marginal), > 0.015 (no conforme). <strong>Importante:</strong> Benford requiere datos que abarquen varios √≥rdenes de magnitud; para variables biom√©dicas estrechas, la prueba tiene baja potencia y se pondera menos.</p>

            <h4>Prueba 4 ‚Äî Rachas (Wald-Wolfowitz)</h4>
            <p>R = n√∫mero de rachas respecto a la mediana. E(R) = 2n‚ÇÅn‚ÇÇ/n + 1. Bajo n > 20, Z = (R - E(R))/‚àöVar(R) es aprox. normal. El p-valor Monte Carlo permuta los datos y cuenta rachas en cada permutaci√≥n.</p>

            <h4>Prueba 5 ‚Äî Autocorrelaci√≥n</h4>
            <p>r(k) = Œ£(x·µ¢-xÃÑ)(x·µ¢‚Çä‚Çñ-xÃÑ) / Œ£(x·µ¢-xÃÑ)¬≤ para lags k=1,...,5. Banda de ¬±1.96/‚àön bajo H‚ÇÄ. El p-valor para lag-1 se obtiene por Monte Carlo.</p>

            <h4>Prueba 6 ‚Äî Entrop√≠a de Shannon</h4>
            <p>H = -Œ£ p·µ¢ log‚ÇÇ(p·µ¢) sobre los d√≠gitos terminales. Se compara contra la distribuci√≥n de H obtenida en B simulaciones de datos reales redondeados.</p>

            <h4>Prueba 7 ‚Äî Tasa de Duplicados</h4>
            <p>Se calcula la proporci√≥n de valores √∫nicos y se compara contra la distribuci√≥n obtenida por simulaci√≥n. La tasa esperada depende fuertemente de n, œÉ y la resoluci√≥n del instrumento.</p>

            <h4>Prueba 8 ‚Äî Momentos (Curtosis y Asimetr√≠a)</h4>
            <p>Curtosis excess = m‚ÇÑ/s‚Å¥ - 3. Asimetr√≠a = m‚ÇÉ/s¬≥. Se comparan contra distribuciones de referencia por Monte Carlo.</p>

            <h4>Prueba 9 ‚Äî MSSD de Von Neumann</h4>
            <p>MSSD = Œ£(x·µ¢‚Çä‚ÇÅ-x·µ¢)¬≤/(n-1). El ratio Œ∑¬≤ = MSSD/s¬≤ tiene E(Œ∑¬≤)=2 bajo independencia. Œ∑¬≤ < 2 sugiere autocorrelaci√≥n positiva; Œ∑¬≤ > 2 sugiere alternaci√≥n. P-valor por Monte Carlo.</p>

            <h4>Puntuaci√≥n Compuesta</h4>
            <p>Se combinan los p-valores de las 9 pruebas usando el m√©todo de Fisher: X¬≤ = -2Œ£ln(p·µ¢), que bajo H‚ÇÄ conjunta sigue œá¬≤(2k). Esto evita la arbitrariedad de pesos subjetivos y proporciona un test √≥mnibus con p-valor formal.</p>

            <h4>Referencias</h4>
            <ol class="ref-list">
                <li>Mosimann, J.E., Wiseman, C.V. & Edelman, R.E. (1995). Data fabrication: Can people generate random digits? <em>Accountability in Research</em>, 4(1), 31-55.</li>
                <li>Benford, F. (1938). The law of anomalous numbers. <em>Proc. American Philosophical Society</em>, 78(4), 551-572.</li>
                <li>Nigrini, M.J. (2012). <em>Benford's Law: Applications for Forensic Accounting, Auditing, and Fraud Detection</em>. Wiley.</li>
                <li>von Neumann, J. (1941). Distribution of the ratio of the mean square successive difference to the variance. <em>Annals of Mathematical Statistics</em>, 12(4), 367-395.</li>
                <li>Fisher, R.A. (1925). <em>Statistical Methods for Research Workers</em>. Oliver & Boyd.</li>
                <li>Wald, A. & Wolfowitz, J. (1940). On a test whether two samples are from the same population. <em>Annals of Mathematical Statistics</em>, 11(2), 147-162.</li>
                <li>Good, P. (2005). <em>Permutation, Parametric, and Bootstrap Tests of Hypotheses</em>. Springer, 3rd ed.</li>
                <li>Al-Marzouki, S. et al. (2005). Are these data real? Statistical methods for the detection of data fabrication in clinical trials. <em>BMJ</em>, 331, 267-270.</li>
            </ol>
        </div>
    </div>

    <footer class="footer">
        <p>StatForensics Lab v3.0 ¬∑ Herramienta educativa e investigativa ¬∑ <a href="https://bioestadisticaedu.com" target="_blank">bioestadisticaedu.com</a></p>
        <p>Los hallazgos deben interpretarse en contexto cl√≠nico y metodol√≥gico. Esta herramienta no emite juicios.</p>
    </footer>
</div>

<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  PRESETS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const PRESETS = {
    hb:      { name:'Hemoglobina',       unit:'g/L',      mu:140,   sigma:12,   dec:0 },
    glucose: { name:'Glucemia',          unit:'mg/dL',    mu:95,    sigma:12,   dec:0 },
    chol:    { name:'Colesterol Total',  unit:'mg/dL',    mu:200,   sigma:35,   dec:0 },
    sbp:     { name:'Presi√≥n Sist√≥lica', unit:'mmHg',     mu:120,   sigma:14,   dec:0 },
    hr:      { name:'Frec. Card√≠aca',    unit:'lpm',      mu:72,    sigma:10,   dec:0 },
    temp:    { name:'Temperatura',       unit:'¬∞C',       mu:36.7,  sigma:0.4,  dec:1 },
    wbc:     { name:'Leucocitos',        unit:'√ó10¬≥/¬µL',  mu:7.5,   sigma:2.0,  dec:1 },
    plt:     { name:'Plaquetas',         unit:'√ó10¬≥/¬µL',  mu:250,   sigma:60,   dec:0 },
    crea:    { name:'Creatinina',        unit:'mg/dL',    mu:0.9,   sigma:0.2,  dec:2 },
    bmi:     { name:'IMC',              unit:'kg/m¬≤',    mu:25.5,  sigma:4.0,  dec:1 },
};

function applyPreset() {
    const v = document.getElementById('varSelect').value;
    if (v !== 'custom' && PRESETS[v]) {
        document.getElementById('popMean').value = PRESETS[v].mu;
        document.getElementById('popSD').value = PRESETS[v].sigma;
        document.getElementById('decimals').value = PRESETS[v].dec;
    }
}
applyPreset();

function getConfig() {
    return {
        mu: parseFloat(document.getElementById('popMean').value) || 140,
        sigma: parseFloat(document.getElementById('popSD').value) || 12,
        dec: parseInt(document.getElementById('decimals').value) || 0,
        nSim: parseInt(document.getElementById('nSim').value) || 5000
    };
}

function getVarInfo() {
    const v = document.getElementById('varSelect').value;
    if (v !== 'custom' && PRESETS[v]) return PRESETS[v];
    return { name: 'Variable personalizada', unit: '' };
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  MATH UTILITIES
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function boxMuller() {
    let u = 0, v = 0;
    while (u === 0) u = Math.random();
    while (v === 0) v = Math.random();
    return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
}

function roundTo(val, dec) {
    const f = Math.pow(10, dec);
    return Math.round(val * f) / f;
}

function genNormalSample(n, mu, sigma, dec) {
    const arr = [];
    for (let i = 0; i < n; i++) arr.push(roundTo(mu + boxMuller() * sigma, dec));
    return arr;
}

function mean(a) { return a.reduce((s,x) => s+x, 0) / a.length; }
function variance(a) { const m = mean(a); return a.reduce((s,x) => s + (x-m)**2, 0) / (a.length-1); }
function sd(a) { return Math.sqrt(variance(a)); }
function median(a) { const s = [...a].sort((x,y)=>x-y); const m = Math.floor(s.length/2); return s.length%2 ? s[m] : (s[m-1]+s[m])/2; }
function skewness(a) { const n=a.length, m=mean(a), s=sd(a); if(!s) return 0; return a.reduce((sum,x)=>sum+((x-m)/s)**3,0)*n/((n-1)*(n-2)||1); }
function kurtosisExcess(a) { const n=a.length, m=mean(a), s=sd(a); if(!s)return 0; return a.reduce((sum,x)=>sum+((x-m)/s)**4,0)/n - 3; }

function lastDigits(a, dec) {
    return a.map(x => {
        const s = Math.abs(x).toFixed(dec);
        return parseInt(s[s.length - 1]);
    });
}

function firstDigits(a) {
    return a.map(x => {
        const s = Math.abs(x).toExponential();
        return parseInt(s[0]);
    }).filter(d => d >= 1 && d <= 9);
}

function chiSqUniform(digits, n) {
    const counts = new Array(10).fill(0);
    digits.forEach(d => counts[d]++);
    return counts.reduce((s,c) => s + (c - n/10)**2 / (n/10), 0);
}

function countRuns(a) {
    const med = median(a);
    const signs = a.map(x => x >= med);
    let runs = 1;
    for (let i = 1; i < signs.length; i++) if (signs[i] !== signs[i-1]) runs++;
    return runs;
}

function autocorr(a, lag) {
    const n = a.length, m = mean(a);
    let num = 0, den = 0;
    for (let i = 0; i < n; i++) den += (a[i]-m)**2;
    if (!den) return 0;
    for (let i = 0; i < n-lag; i++) num += (a[i]-m)*(a[i+lag]-m);
    return num / den;
}

function shannonH(digits) {
    const counts = {};
    digits.forEach(d => counts[d] = (counts[d]||0) + 1);
    const n = digits.length;
    let H = 0;
    for (const k in counts) { const p = counts[k]/n; if (p>0) H -= p * Math.log2(p); }
    return H;
}

function uniqueRatio(a) { return new Set(a.map(x => x.toFixed(10))).size / a.length; }

function mssd(a) {
    let sum = 0;
    for (let i = 1; i < a.length; i++) sum += (a[i] - a[i-1])**2;
    return sum / (a.length - 1);
}

function ksStatistic(data, mu, sigma) {
    const sorted = [...data].sort((a,b) => a-b);
    const n = sorted.length;
    let D = 0;
    for (let i = 0; i < n; i++) {
        const Fn = (i+1)/n;
        const Fn_prev = i/n;
        const z = (sorted[i] - mu) / sigma;
        const Fz = normalCDF(z);
        D = Math.max(D, Math.abs(Fn - Fz), Math.abs(Fn_prev - Fz));
    }
    return D;
}

function normalCDF(z) {
    const a1=0.254829592, a2=-0.284496736, a3=1.421413741, a4=-1.453152027, a5=1.061405429;
    const p=0.3275911;
    const sign = z < 0 ? -1 : 1;
    z = Math.abs(z) / Math.sqrt(2);
    const t = 1 / (1 + p*z);
    const y = 1 - (((((a5*t+a4)*t)+a3)*t+a2)*t+a1)*t * Math.exp(-z*z);
    return 0.5 * (1 + sign*y);
}

function invNormal(p) {
    if (p<=0) return -4; if (p>=1) return 4; if (p===0.5) return 0;
    const sign = p<0.5 ? -1 : 1;
    const pp = p<0.5 ? p : 1-p;
    const t = Math.sqrt(-2*Math.log(pp));
    return sign*(t-(2.515517+0.802853*t+0.010328*t*t)/(1+1.432788*t+0.189269*t*t+0.001308*t*t*t));
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  DATA GENERATORS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function generateData(type) {
    const { mu, sigma, dec } = getConfig();
    const n = 120;
    let data = [];

    if (type === 'real') {
        data = genNormalSample(n, mu, sigma, dec);
    } else if (type === 'fake_round') {
        for (let i = 0; i < n; i++) {
            let v = mu + boxMuller() * sigma * 0.8;
            if (Math.random() < 0.4) {
                const step = dec === 0 ? 5 : 5 * Math.pow(10, -dec);
                v = Math.round(v / step) * step;
            }
            data.push(roundTo(v, dec));
        }
    } else if (type === 'fake_alt') {
        let current = mu;
        for (let i = 0; i < n; i++) {
            const dir = (i % 2 === 0) ? 1 : -1;
            current += dir * Math.random() * sigma * 0.5;
            if (Math.abs(current - mu) > sigma * 1.5) current = mu + boxMuller() * sigma * 0.3;
            let v = current;
            if (Math.random() < 0.2) {
                const step = dec === 0 ? 5 : 5 * Math.pow(10, -dec);
                v = Math.round(v / step) * step;
            }
            data.push(roundTo(v, dec));
        }
    } else if (type === 'fake_narrow') {
        for (let i = 0; i < n; i++) {
            const v = mu + (Math.random() - 0.5) * sigma * 2;
            data.push(roundTo(v, dec));
        }
    }

    document.getElementById('dataInput').value = data.join(', ');
    runFullAnalysis();
}

function clearAll() {
    document.getElementById('dataInput').value = '';
    document.getElementById('dashboard').style.display = 'none';
    document.getElementById('scoreBand').style.display = 'none';
    document.getElementById('reportPanel').style.display = 'none';
    document.getElementById('simBar').style.display = 'none';
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  MONTE CARLO ENGINE (async for UI updates)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
async function runFullAnalysis() {
    const raw = document.getElementById('dataInput').value;
    const data = raw.split(/[\s,;\t\n]+/).map(d => parseFloat(d)).filter(d => !isNaN(d));

    if (data.length < 10) {
        alert('Se requieren al menos 10 observaciones para un an√°lisis confiable.');
        return;
    }

    const { mu, sigma, dec, nSim } = getConfig();
    const n = data.length;
    const info = getVarInfo();

    // Show progress
    const simBar = document.getElementById('simBar');
    const simFill = document.getElementById('simFill');
    const simLabel = document.getElementById('simLabel');
    simBar.style.display = 'block';
    simFill.style.width = '0%';
    simLabel.textContent = `Preparando ${nSim.toLocaleString()} simulaciones...`;

    // Clear
    for (let i = 1; i <= 10; i++) {
        ['p','s','f'].forEach(prefix => {
            const el = document.getElementById(prefix + i);
            if (el) el.innerHTML = '';
        });
    }

    // ‚îÄ‚îÄ Observed Statistics ‚îÄ‚îÄ
    const obs = {};
    const digs = lastDigits(data, dec);
    obs.chiDigit = chiSqUniform(digs, n);
    obs.runs = countRuns(data);
    obs.r1 = autocorr(data, 1);
    obs.entropy = shannonH(digs);
    obs.uniqueRatio = uniqueRatio(data);
    obs.kurtosis = kurtosisExcess(data);
    obs.skewness = skewness(data);
    obs.mssd = mssd(data);
    obs.mssdRatio = obs.mssd / (variance(data) || 1);
    obs.ks = ksStatistic(data, mu, sigma);

    const fd = firstDigits(data);
    const benfordExp = [.301,.176,.125,.097,.079,.067,.058,.051,.046];
    const fdCounts = new Array(9).fill(0);
    fd.forEach(d => fdCounts[d-1]++);
    obs.benfordMAD = fdCounts.reduce((s,c,i) => s + Math.abs(c/fd.length - benfordExp[i]), 0) / 9;

    // ‚îÄ‚îÄ Monte Carlo Simulation ‚îÄ‚îÄ
    const mc = {
        chiDigit: [], runs: [], r1: [], entropy: [],
        uniqueRatio: [], kurtosis: [], skewness: [],
        mssdRatio: [], ks: [], benfordMAD: []
    };

    const batchSize = 200;
    const batches = Math.ceil(nSim / batchSize);

    for (let b = 0; b < batches; b++) {
        const count = Math.min(batchSize, nSim - b * batchSize);
        for (let s = 0; s < count; s++) {
            const sim = genNormalSample(n, mu, sigma, dec);
            const simDigs = lastDigits(sim, dec);

            mc.chiDigit.push(chiSqUniform(simDigs, n));
            mc.runs.push(countRuns(sim));
            mc.r1.push(autocorr(sim, 1));
            mc.entropy.push(shannonH(simDigs));
            mc.uniqueRatio.push(uniqueRatio(sim));
            mc.kurtosis.push(kurtosisExcess(sim));
            mc.skewness.push(skewness(sim));
            const simVar = variance(sim);
            mc.mssdRatio.push(simVar ? mssd(sim)/simVar : 2);
            mc.ks.push(ksStatistic(sim, mu, sigma));

            const simFD = firstDigits(sim);
            const simFDC = new Array(9).fill(0);
            simFD.forEach(d => simFDC[d-1]++);
            mc.benfordMAD.push(simFDC.reduce((sum,c,i) => sum + Math.abs(c/simFD.length - benfordExp[i]), 0) / 9);
        }
        // Update progress
        const pct = Math.round(((b+1)*batchSize)/nSim*100);
        simFill.style.width = Math.min(100, pct) + '%';
        simLabel.textContent = `Simulaci√≥n Monte Carlo: ${Math.min((b+1)*batchSize, nSim).toLocaleString()} / ${nSim.toLocaleString()}`;
        await new Promise(r => setTimeout(r, 0)); // yield to UI
    }

    simBar.style.display = 'none';

    // ‚îÄ‚îÄ P-values (two-sided where appropriate) ‚îÄ‚îÄ
    function pvalGreater(obsVal, simArr) {
        return (simArr.filter(s => s >= obsVal).length + 1) / (simArr.length + 1);
    }
    function pvalLess(obsVal, simArr) {
        return (simArr.filter(s => s <= obsVal).length + 1) / (simArr.length + 1);
    }
    function pvalTwoSided(obsVal, simArr) {
        const m = mean(simArr);
        const extreme = simArr.filter(s => Math.abs(s - m) >= Math.abs(obsVal - m)).length;
        return (extreme + 1) / (simArr.length + 1);
    }

    const pvals = {};
    pvals.ks = pvalGreater(obs.ks, mc.ks);
    pvals.chiDigit = pvalGreater(obs.chiDigit, mc.chiDigit);
    pvals.benford = pvalGreater(obs.benfordMAD, mc.benfordMAD);
    pvals.runs = pvalTwoSided(obs.runs, mc.runs);
    pvals.r1 = pvalTwoSided(obs.r1, mc.r1);
    pvals.entropy = pvalLess(obs.entropy, mc.entropy);
    pvals.uniqueRatio = pvalTwoSided(obs.uniqueRatio, mc.uniqueRatio);
    pvals.kurtosis = pvalTwoSided(obs.kurtosis, mc.kurtosis);
    pvals.mssdRatio = pvalTwoSided(obs.mssdRatio, mc.mssdRatio);

    // ‚îÄ‚îÄ Percentiles for MC distributions ‚îÄ‚îÄ
    function percentile(arr, p) {
        const sorted = [...arr].sort((a,b) => a-b);
        const idx = p * (sorted.length - 1);
        const lo = Math.floor(idx), hi = Math.ceil(idx);
        return sorted[lo] + (sorted[hi] - sorted[lo]) * (idx - lo);
    }

    function mcInterval(arr) {
        return [percentile(arr, 0.025), percentile(arr, 0.975)];
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  RENDER EACH TEST
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // --- T1: Distribution (KS) ---
    const [ksLo, ksHi] = mcInterval(mc.ks);
    try {
        const densityX = d3.range(mu - 4*sigma, mu + 4*sigma, sigma/20);
        const densityCurve = densityX.map(x => ({
            x,
            y: Math.exp(-0.5*((x-mu)/sigma)**2) / (sigma * Math.sqrt(2*Math.PI))
        }));
        // Scale density to histogram
        const binWidth = sigma / 3;
        const scaleFactor = n * binWidth;
        const p1 = Plot.plot({
            height: 200, style: { fontSize: '11px' },
            marks: [
                Plot.rectY(data, Plot.binX({y:"count"}, {x:d=>d, fill:"#3498db", fillOpacity:0.6, thresholds: 20})),
                Plot.line(densityCurve, {x:"x", y: d => d.y * scaleFactor, stroke:"#c0392b", strokeWidth:2}),
                Plot.ruleY([0])
            ],
            x: { label: `${info.name} (${info.unit})` },
            y: { label: "Frecuencia", grid: true }
        });
        document.getElementById('p1').append(p1);
    } catch(e) {}
    renderStats('s1', [
        ['D de Kolmogorov-Smirnov', obs.ks.toFixed(4)],
        ['IC 95% MC para D', `[${ksLo.toFixed(4)}, ${ksHi.toFixed(4)}]`],
        ['p-valor (Monte Carlo)', formatP(pvals.ks)]
    ]);
    renderFinding('f1', pvals.ks, interpretKS(pvals.ks, obs.ks));
    setBadge('b1', pvals.ks);

    // --- T2: Last Digit ---
    const digitCounts = new Array(10).fill(0);
    digs.forEach(d => digitCounts[d]++);
    try {
        const dd = d3.range(10).map(i => ({digit:i, pct: digitCounts[i]/n*100, susp: digitCounts[i]/n > 0.15}));
        const p2 = Plot.plot({
            height: 200, style: { fontSize:'11px' },
            x: { domain: d3.range(10), label:"√öltimo d√≠gito", tickFormat: d=>d },
            y: { label: "%" },
            marks: [
                Plot.barY(dd, {x:"digit", y:"pct", fill: d => d.susp ? "#e74c3c":"#27ae60"}),
                Plot.ruleY([10], {stroke:"#333", strokeDasharray:"5,3", strokeWidth:1.5}),
                Plot.text([{x:8,y:12}], {x:"x",y:"y",text:d=>"10% esperado", fontSize:9, fill:"#666"})
            ]
        });
        document.getElementById('p2').append(p2);
    } catch(e) {}
    const [chiLo, chiHi] = mcInterval(mc.chiDigit);
    renderStats('s2', [
        ['œá¬≤ observado', obs.chiDigit.toFixed(2)],
        ['IC 95% MC para œá¬≤', `[${chiLo.toFixed(2)}, ${chiHi.toFixed(2)}]`],
        ['p-valor (Monte Carlo)', formatP(pvals.chiDigit)],
        ['D√≠gito m√°s frecuente', `${digitCounts.indexOf(Math.max(...digitCounts))} (${(Math.max(...digitCounts)/n*100).toFixed(1)}%)`]
    ]);
    renderFinding('f2', pvals.chiDigit, interpretDigit(pvals.chiDigit, digitCounts, n));
    setBadge('b2', pvals.chiDigit);

    // --- T3: Benford ---
    try {
        const bData = [];
        for (let i=1; i<=9; i++) {
            bData.push({digit:i, type:'Observado', pct: fdCounts[i-1]/fd.length*100});
            bData.push({digit:i, type:'Benford te√≥rico', pct: benfordExp[i-1]*100});
        }
        const p3 = Plot.plot({
            height: 200, style:{fontSize:'11px'},
            x:{domain:d3.range(1,10), label:"Primer d√≠gito significativo"},
            y:{label:"%"},
            color:{domain:['Observado','Benford te√≥rico'], range:['#3498db','#e74c3c'], legend:true},
            marks:[
                Plot.barY(bData.filter(d=>d.type==='Benford te√≥rico'), {x:"digit",y:"pct",fill:"type", fillOpacity:0.3, dx:3}),
                Plot.barY(bData.filter(d=>d.type==='Observado'), {x:"digit",y:"pct",fill:"type", dx:-3}),
            ]
        });
        document.getElementById('p3').append(p3);
    } catch(e) {}
    renderStats('s3', [
        ['MAD de Nigrini', obs.benfordMAD.toFixed(4)],
        ['IC 95% MC para MAD', `[${percentile(mc.benfordMAD,.025).toFixed(4)}, ${percentile(mc.benfordMAD,.975).toFixed(4)}]`],
        ['p-valor (Monte Carlo)', formatP(pvals.benford)],
        ['Nota', 'Benford tiene baja potencia para rangos estrechos']
    ]);
    renderFinding('f3', pvals.benford, interpretBenford(pvals.benford, obs.benfordMAD));
    setBadge('b3', pvals.benford);

    // --- T4: Runs ---
    const runsExp = mean(mc.runs);
    try {
        const runsSigns = data.map((x,i) => ({i, val:x, above: x >= median(data)}));
        const p4 = Plot.plot({
            height: 200, style:{fontSize:'11px'},
            marks: [
                Plot.dot(runsSigns, {x:"i", y:"val", fill: d=>d.above?"#27ae60":"#e74c3c", r:2.5}),
                Plot.line(runsSigns, {x:"i", y:"val", strokeOpacity:0.15}),
                Plot.ruleY([median(data)], {stroke:"#333", strokeDasharray:"4,4"})
            ],
            x:{label:"Orden de entrada"}, y:{label:"Valor"}
        });
        document.getElementById('p4').append(p4);
    } catch(e) {}
    renderStats('s4', [
        ['Rachas observadas', obs.runs],
        ['Rachas esperadas (MC)', runsExp.toFixed(1)],
        ['IC 95% MC', `[${percentile(mc.runs,.025).toFixed(0)}, ${percentile(mc.runs,.975).toFixed(0)}]`],
        ['p-valor (Monte Carlo, bilateral)', formatP(pvals.runs)]
    ]);
    renderFinding('f4', pvals.runs, interpretRuns(pvals.runs, obs.runs, runsExp));
    setBadge('b4', pvals.runs);

    // --- T5: Autocorrelation ---
    const acfLags = [1,2,3,4,5];
    const acfVals = acfLags.map(k => autocorr(data, k));
    const acfBand = 1.96 / Math.sqrt(n);
    try {
        const acfData = acfLags.map((k,i) => ({lag:k, r: acfVals[i]}));
        const p5 = Plot.plot({
            height: 200, style:{fontSize:'11px'},
            x:{label:"Lag", domain:[0.5, 5.5]},
            y:{label:"r(k)", domain:[-0.5,0.5]},
            marks: [
                Plot.ruleY([0], {stroke:"#333"}),
                Plot.rect([{x1:0.5,x2:5.5,y1:-acfBand,y2:acfBand}], {x1:"x1",x2:"x2",y1:"y1",y2:"y2",fill:"#3498db",fillOpacity:0.1}),
                Plot.ruleY([-acfBand], {stroke:"#3498db",strokeDasharray:"4,4"}),
                Plot.ruleY([acfBand], {stroke:"#3498db",strokeDasharray:"4,4"}),
                Plot.barY(acfData, {x:"lag", y:"r", fill: d=> Math.abs(d.r)>acfBand ? "#e74c3c":"#27ae60", insetLeft:10, insetRight:10})
            ]
        });
        document.getElementById('p5').append(p5);
    } catch(e) {}
    renderStats('s5', [
        ['r(1) observado', obs.r1.toFixed(4)],
        ['IC 95% MC para r(1)', `[${percentile(mc.r1,.025).toFixed(4)}, ${percentile(mc.r1,.975).toFixed(4)}]`],
        ['Banda ¬±1.96/‚àön', `¬±${acfBand.toFixed(4)}`],
        ['p-valor r(1) (MC, bilateral)', formatP(pvals.r1)]
    ]);
    renderFinding('f5', pvals.r1, interpretAutocorr(pvals.r1, obs.r1));
    setBadge('b5', pvals.r1);

    // --- T6: Entropy ---
    const Hmax = Math.log2(10);
    try {
        const p6 = Plot.plot({
            height: 160, style:{fontSize:'11px'},
            marks: [
                Plot.rectY(mc.entropy, Plot.binX({y:"count"}, {x:d=>d, fill:"#bdc3c7", fillOpacity:0.5, thresholds:30})),
                Plot.ruleX([obs.entropy], {stroke:"#e74c3c", strokeWidth:2.5}),
                Plot.ruleX([Hmax], {stroke:"#27ae60", strokeDasharray:"4,4"}),
                Plot.text([{x:obs.entropy, y:0}], {x:"x",y:"y",text:d=>"Obs", dy:-10, fill:"#e74c3c", fontSize:10, fontWeight:"bold"}),
                Plot.ruleY([0])
            ],
            x:{label:"Entrop√≠a H (bits)"}, y:{label:"Frecuencia MC", grid:true}
        });
        document.getElementById('p6').append(p6);
    } catch(e) {}
    renderStats('s6', [
        ['H observada', obs.entropy.toFixed(4) + ' bits'],
        ['H m√°xima (uniforme)', Hmax.toFixed(4) + ' bits'],
        ['Ratio H/Hmax', (obs.entropy/Hmax*100).toFixed(1) + '%'],
        ['IC 95% MC', `[${percentile(mc.entropy,.025).toFixed(4)}, ${percentile(mc.entropy,.975).toFixed(4)}]`],
        ['p-valor (MC, cola inferior)', formatP(pvals.entropy)]
    ]);
    renderFinding('f6', pvals.entropy, interpretEntropy(pvals.entropy, obs.entropy, Hmax));
    setBadge('b6', pvals.entropy);

    // --- T7: Duplicates ---
    const nUnique = new Set(data.map(x => x.toFixed(10))).size;
    try {
        const p7 = Plot.plot({
            height: 160, style:{fontSize:'11px'},
            marks: [
                Plot.rectY(mc.uniqueRatio, Plot.binX({y:"count"}, {x:d=>d*100, fill:"#bdc3c7", fillOpacity:0.5, thresholds:30})),
                Plot.ruleX([obs.uniqueRatio*100], {stroke:"#e74c3c", strokeWidth:2.5}),
                Plot.text([{x:obs.uniqueRatio*100,y:0}], {x:"x",y:"y",text:d=>"Obs",dy:-10,fill:"#e74c3c",fontSize:10,fontWeight:"bold"}),
                Plot.ruleY([0])
            ],
            x:{label:"% Valores √∫nicos"}, y:{label:"Frecuencia MC", grid:true}
        });
        document.getElementById('p7').append(p7);
    } catch(e) {}
    renderStats('s7', [
        ['Valores √∫nicos', `${nUnique} / ${n} (${(obs.uniqueRatio*100).toFixed(1)}%)`],
        ['Tasa esperada (MC)', `${(mean(mc.uniqueRatio)*100).toFixed(1)}%`],
        ['IC 95% MC', `[${(percentile(mc.uniqueRatio,.025)*100).toFixed(1)}%, ${(percentile(mc.uniqueRatio,.975)*100).toFixed(1)}%]`],
        ['p-valor (MC, bilateral)', formatP(pvals.uniqueRatio)]
    ]);
    renderFinding('f7', pvals.uniqueRatio, interpretDuplicates(pvals.uniqueRatio, obs.uniqueRatio, mean(mc.uniqueRatio)));
    setBadge('b7', pvals.uniqueRatio);

    // --- T8: Shape (QQ) ---
    try {
        const sorted = [...data].sort((a,b)=>a-b);
        const qq = sorted.map((v,i) => ({
            obs: v,
            theo: mu + sigma * invNormal((i+0.5)/n)
        }));
        const extent = [Math.min(mu-3*sigma, Math.min(...data)), Math.max(mu+3*sigma, Math.max(...data))];
        const p8 = Plot.plot({
            height: 200, style:{fontSize:'11px'},
            marks: [
                Plot.line([extent, extent].map((e,i) => ({x:extent[i],y:extent[i]})), {x:"x",y:"y",stroke:"#999",strokeDasharray:"4,4"}),
                // Manual identity line
                Plot.line([{x:extent[0],y:extent[0]},{x:extent[1],y:extent[1]}], {x:"x",y:"y",stroke:"#999",strokeDasharray:"4,4"}),
                Plot.dot(qq, {x:"theo",y:"obs",fill:"#e67e22",r:2.5,fillOpacity:0.6})
            ],
            x:{label:"Cuantiles te√≥ricos N(Œº,œÉ)", grid:true},
            y:{label:"Cuantiles observados", grid:true}
        });
        document.getElementById('p8').append(p8);
    } catch(e) {}
    renderStats('s8', [
        ['Curtosis excess', obs.kurtosis.toFixed(3) + (obs.kurtosis < -0.5 ? ' (platoc√∫rtica)' : obs.kurtosis > 1 ? ' (leptoc√∫rtica)' : ' (mesoc√∫rtica)')],
        ['IC 95% MC curtosis', `[${percentile(mc.kurtosis,.025).toFixed(3)}, ${percentile(mc.kurtosis,.975).toFixed(3)}]`],
        ['Asimetr√≠a', obs.skewness.toFixed(3)],
        ['p-valor curtosis (MC)', formatP(pvals.kurtosis)]
    ]);
    renderFinding('f8', pvals.kurtosis, interpretShape(pvals.kurtosis, obs.kurtosis, obs.skewness));
    setBadge('b8', pvals.kurtosis);

    // --- T9: MSSD (Von Neumann) ---
    try {
        const p9 = Plot.plot({
            height: 160, style:{fontSize:'11px'},
            marks: [
                Plot.rectY(mc.mssdRatio, Plot.binX({y:"count"}, {x:d=>d, fill:"#bdc3c7", fillOpacity:0.5, thresholds:30})),
                Plot.ruleX([obs.mssdRatio], {stroke:"#e74c3c", strokeWidth:2.5}),
                Plot.ruleX([2], {stroke:"#27ae60", strokeDasharray:"4,4", strokeWidth:1.5}),
                Plot.text([{x:obs.mssdRatio,y:0}], {x:"x",y:"y",text:d=>"Obs",dy:-10,fill:"#e74c3c",fontSize:10,fontWeight:"bold"}),
                Plot.text([{x:2,y:0}], {x:"x",y:"y",text:d=>"Œ∑¬≤=2",dy:-10,fill:"#27ae60",fontSize:9}),
                Plot.ruleY([0])
            ],
            x:{label:"Œ∑¬≤ = MSSD/Varianza"}, y:{label:"Frecuencia MC", grid:true}
        });
        document.getElementById('p9').append(p9);
    } catch(e) {}
    renderStats('s9', [
        ['MSSD', obs.mssd.toFixed(2)],
        ['Varianza muestral', variance(data).toFixed(2)],
        ['Œ∑¬≤ = MSSD/Var', obs.mssdRatio.toFixed(4)],
        ['Œ∑¬≤ esperado', '2.0000 (independencia)'],
        ['IC 95% MC', `[${percentile(mc.mssdRatio,.025).toFixed(4)}, ${percentile(mc.mssdRatio,.975).toFixed(4)}]`],
        ['p-valor (MC, bilateral)', formatP(pvals.mssdRatio)]
    ]);
    renderFinding('f9', pvals.mssdRatio, interpretMSSD(pvals.mssdRatio, obs.mssdRatio));
    setBadge('b9', pvals.mssdRatio);

    // --- T10: Summary ---
    document.getElementById('summaryContent').innerHTML = buildSummaryHTML(data, info, mu, sigma, dec, n);

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  FISHER'S COMBINED TEST
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const allPvals = [
        { name: 'Kolmogorov-Smirnov (distribuci√≥n)', p: pvals.ks, weight: 'Est√°ndar' },
        { name: 'œá¬≤ d√≠gito terminal', p: pvals.chiDigit, weight: 'Est√°ndar' },
        { name: 'Benford (primer d√≠gito)', p: pvals.benford, weight: 'Baja potencia*' },
        { name: 'Rachas (Wald-Wolfowitz)', p: pvals.runs, weight: 'Est√°ndar' },
        { name: 'Autocorrelaci√≥n lag-1', p: pvals.r1, weight: 'Est√°ndar' },
        { name: 'Entrop√≠a de Shannon', p: pvals.entropy, weight: 'Est√°ndar' },
        { name: 'Tasa de duplicados', p: pvals.uniqueRatio, weight: 'Est√°ndar' },
        { name: 'Curtosis', p: pvals.kurtosis, weight: 'Est√°ndar' },
        { name: 'MSSD de Von Neumann', p: pvals.mssdRatio, weight: 'Est√°ndar' },
    ];

    // Fisher's method: X¬≤ = -2 Œ£ ln(p·µ¢)
    const fisherStat = -2 * allPvals.reduce((s, t) => s + Math.log(Math.max(t.p, 1e-10)), 0);
    const fisherDF = 2 * allPvals.length;
    // Chi-square survival function approximation
    const fisherP = 1 - chiSquareCDF(fisherStat, fisherDF);

    // Number of significant tests
    const nSig005 = allPvals.filter(t => t.p < 0.05).length;
    const nSig010 = allPvals.filter(t => t.p < 0.10).length;

    // Score display
    const scoreBand = document.getElementById('scoreBand');
    scoreBand.style.display = 'block';
    scoreBand.className = 'score-band';

    const scoreCircle = document.getElementById('scoreCircle');
    const scoreTitle = document.getElementById('scoreTitle');
    const scoreDesc = document.getElementById('scoreDesc');

    if (fisherP > 0.10) {
        scoreBand.classList.add('level-low');
        scoreCircle.textContent = nSig005;
        scoreTitle.textContent = 'Los datos son estad√≠sticamente compatibles con la distribuci√≥n de referencia';
        scoreDesc.textContent = `Prueba √≥mnibus de Fisher: œá¬≤ = ${fisherStat.toFixed(1)}, gl = ${fisherDF}, p = ${formatP(fisherP)}. ${nSig005} de 9 pruebas individuales con p < 0.05. No se detectan anomal√≠as sistem√°ticas consistentes con fabricaci√≥n.`;
    } else if (fisherP > 0.01) {
        scoreBand.classList.add('level-mid');
        scoreCircle.textContent = nSig005;
        scoreTitle.textContent = 'Se detectan algunas discrepancias con la distribuci√≥n de referencia';
        scoreDesc.textContent = `Prueba √≥mnibus de Fisher: œá¬≤ = ${fisherStat.toFixed(1)}, gl = ${fisherDF}, p = ${formatP(fisherP)}. ${nSig005} de 9 pruebas individuales con p < 0.05. Se recomienda revisi√≥n detallada de las pruebas se√±aladas.`;
    } else {
        scoreBand.classList.add('level-high');
        scoreCircle.textContent = nSig005;
        scoreTitle.textContent = 'Los datos muestran discrepancias significativas con la distribuci√≥n de referencia';
        scoreDesc.textContent = `Prueba √≥mnibus de Fisher: œá¬≤ = ${fisherStat.toFixed(1)}, gl = ${fisherDF}, p = ${formatP(fisherP)}. ${nSig005} de 9 pruebas individuales con p < 0.05. Los patrones observados son inconsistentes con muestreo aleatorio de N(${mu}, ${sigma}¬≤).`;
    }

    document.getElementById('dashboard').style.display = 'grid';

    // ‚îÄ‚îÄ Report ‚îÄ‚îÄ
    buildReport(allPvals, fisherStat, fisherDF, fisherP, nSig005, data, info, mu, sigma, n, nSim);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  CHI-SQUARE CDF (for Fisher's method)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function chiSquareCDF(x, k) {
    // Regularized lower incomplete gamma function via series expansion
    if (x <= 0) return 0;
    const a = k / 2;
    const gln = lnGamma(a);
    let sum = 0, term = 1 / a;
    sum = term;
    for (let n = 1; n < 200; n++) {
        term *= (x/2) / (a + n);
        sum += term;
        if (Math.abs(term) < 1e-12 * Math.abs(sum)) break;
    }
    return Math.min(1, sum * Math.exp(-x/2 + a * Math.log(x/2) - gln));
}

function lnGamma(z) {
    // Lanczos approximation
    const g = 7;
    const c = [0.99999999999980993, 676.5203681218851, -1259.1392167224028,
        771.32342877765313, -176.61502916214059, 12.507343278686905,
        -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];
    if (z < 0.5) return Math.log(Math.PI / Math.sin(Math.PI * z)) - lnGamma(1 - z);
    z -= 1;
    let x = c[0];
    for (let i = 1; i < g + 2; i++) x += c[i] / (z + i);
    const t = z + g + 0.5;
    return 0.5 * Math.log(2 * Math.PI) + (z + 0.5) * Math.log(t) - t + Math.log(x);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  INTERPRETATION FUNCTIONS (neutral language)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function interpretKS(p, D) {
    if (p > 0.10) return `El estad√≠stico D = ${D.toFixed(4)} se encuentra dentro del rango esperado por simulaci√≥n. La distribuci√≥n observada es compatible con N(Œº, œÉ).`;
    if (p > 0.01) return `El estad√≠stico D = ${D.toFixed(4)} es moderadamente alto. La distribuci√≥n observada difiere de N(Œº, œÉ). Esto puede indicar una distribuci√≥n de origen diferente, errores de medici√≥n, o selecci√≥n no aleatoria.`;
    return `El estad√≠stico D = ${D.toFixed(4)} excede el rango esperado bajo N(Œº, œÉ). La discrepancia es estad√≠sticamente significativa y merece investigaci√≥n adicional sobre el proceso de generaci√≥n de los datos.`;
}

function interpretDigit(p, counts, n) {
    const maxD = counts.indexOf(Math.max(...counts));
    const maxPct = (Math.max(...counts)/n*100).toFixed(1);
    if (p > 0.10) return `La distribuci√≥n de d√≠gitos terminales es compatible con uniformidad. No se detecta preferencia por d√≠gitos espec√≠ficos.`;
    if (p > 0.01) return `Se observa cierta desviaci√≥n de la uniformidad en los d√≠gitos terminales. El d√≠gito ${maxD} alcanza ${maxPct}%. Esto podr√≠a reflejar redondeo del instrumento o preferencia del observador.`;
    return `La distribuci√≥n de d√≠gitos terminales se desv√≠a significativamente de la uniformidad esperada. El d√≠gito ${maxD} alcanza ${maxPct}% (esperado: 10%). Este patr√≥n es consistente con redondeo preferencial, un hallazgo frecuente en datos generados manualmente.`;
}

function interpretBenford(p, mad) {
    const cl = mad <= 0.006 ? 'conformidad cercana' : mad <= 0.012 ? 'conformidad aceptable' : mad <= 0.015 ? 'conformidad marginal' : 'no conformidad';
    if (p > 0.10) return `MAD = ${mad.toFixed(4)} (${cl}). La distribuci√≥n del primer d√≠gito es compatible con lo esperado. Nota: esta prueba tiene potencia limitada para variables biom√©dicas con rango estrecho.`;
    return `MAD = ${mad.toFixed(4)} (${cl}). Se detecta desviaci√≥n en la distribuci√≥n del primer d√≠gito. Interpretar con cautela: Benford es m√°s informativo cuando los datos cubren varios √≥rdenes de magnitud.`;
}

function interpretRuns(p, obs, exp) {
    const diff = obs - exp;
    if (p > 0.10) return `Se observaron ${obs} rachas (esperadas: ${exp.toFixed(1)}). El n√∫mero de rachas es compatible con aleatoriedad en la secuencia.`;
    if (diff > 0) return `Se observaron ${obs} rachas, m√°s de las ${exp.toFixed(1)} esperadas. El exceso de rachas sugiere alternaci√≥n excesiva: los valores consecutivos tienden a cambiar de lado de la mediana con m√°s frecuencia de lo esperado, un patr√≥n documentado en la generaci√≥n humana de n√∫meros aleatorios.`;
    return `Se observaron ${obs} rachas, menos de las ${exp.toFixed(1)} esperadas. El d√©ficit de rachas sugiere agrupamiento: los valores tienden a permanecer del mismo lado de la mediana, lo que podr√≠a indicar tendencias o bloques copiados.`;
}

function interpretAutocorr(p, r1) {
    if (p > 0.10) return `r(1) = ${r1.toFixed(4)} se encuentra dentro del rango esperado bajo independencia. No se detecta dependencia serial significativa.`;
    if (r1 < 0) return `r(1) = ${r1.toFixed(4)} indica correlaci√≥n serial negativa significativa. Los valores consecutivos tienden a "evitarse" mutuamente. Este patr√≥n es caracter√≠stico de secuencias generadas mentalmente, donde el sujeto intenta producir variabilidad exagerada.`;
    return `r(1) = ${r1.toFixed(4)} indica correlaci√≥n serial positiva significativa. Los valores consecutivos son m√°s similares de lo esperado, lo que podr√≠a indicar arrastre, copia parcial, o tendencia temporal real.`;
}

function interpretEntropy(p, H, Hmax) {
    const pct = (H/Hmax*100).toFixed(1);
    if (p > 0.10) return `H = ${H.toFixed(3)} bits (${pct}% del m√°ximo). La diversidad de d√≠gitos terminales es la esperada bajo muestreo aleatorio.`;
    return `H = ${H.toFixed(3)} bits (${pct}% del m√°ximo). La entrop√≠a es significativamente menor que la esperada, indicando concentraci√≥n de ciertos d√≠gitos terminales. Esto reduce la evidencia de origen aleatorio.`;
}

function interpretDuplicates(p, obsR, expR) {
    if (p > 0.10) return `La tasa de valores √∫nicos (${(obsR*100).toFixed(1)}%) es compatible con la esperada (${(expR*100).toFixed(1)}%) bajo muestreo de N(Œº,œÉ) redondeada.`;
    if (obsR < expR) return `La tasa de valores √∫nicos (${(obsR*100).toFixed(1)}%) es menor que la esperada (${(expR*100).toFixed(1)}%). El exceso de duplicados podr√≠a indicar anclaje a valores preferidos o uso de un repertorio limitado de n√∫meros.`;
    return `La tasa de valores √∫nicos (${(obsR*100).toFixed(1)}%) es mayor que la esperada (${(expR*100).toFixed(1)}%). El d√©ficit de duplicados podr√≠a indicar esfuerzo deliberado por evitar repeticiones, un sesgo documentado en la fabricaci√≥n manual de datos.`;
}

function interpretShape(p, kurt, skew) {
    if (p > 0.10) return `Curtosis excess = ${kurt.toFixed(3)}, asimetr√≠a = ${skew.toFixed(3)}. Los momentos de la distribuci√≥n son compatibles con la normal de referencia.`;
    if (kurt < -0.5) return `Curtosis excess = ${kurt.toFixed(3)} (platoc√∫rtica). La distribuci√≥n es m√°s plana que la normal esperada. Esto es consistente con una distribuci√≥n uniforme, como la que se produce al generar n√∫meros "al azar" dentro de un rango.`;
    return `Curtosis excess = ${kurt.toFixed(3)}, asimetr√≠a = ${skew.toFixed(3)}. La forma de la distribuci√≥n difiere significativamente de la normal de referencia. Investigar si la poblaci√≥n de origen tiene distribuci√≥n diferente a la asumida.`;
}

function interpretMSSD(p, ratio) {
    if (p > 0.10) return `Œ∑¬≤ = ${ratio.toFixed(4)} (esperado: 2.0). El ratio MSSD/varianza es compatible con independencia serial. No se detecta estructura secuencial an√≥mala.`;
    if (ratio > 2) return `Œ∑¬≤ = ${ratio.toFixed(4)} > 2.0. Las diferencias consecutivas son mayores de lo esperado. Esto sugiere alternaci√≥n excesiva: el generador de datos parece evitar valores consecutivos similares, un patr√≥n t√≠pico de la generaci√≥n humana de secuencias pseudoaleatorias.`;
    return `Œ∑¬≤ = ${ratio.toFixed(4)} < 2.0. Las diferencias consecutivas son menores de lo esperado. Esto sugiere autocorrelaci√≥n positiva: valores consecutivos son m√°s similares entre s√≠, lo que podr√≠a indicar tendencias, bloques copiados o arrastre cognitivo.`;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  RENDER HELPERS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function formatP(p) {
    if (p < 0.0001) return '< 0.0001';
    if (p < 0.001) return p.toFixed(4);
    return p.toFixed(3);
}

function renderStats(id, rows) {
    const el = document.getElementById(id);
    if (!el) return;
    el.innerHTML = rows.map(([k,v]) => `<div class="stat-row"><span class="stat-key">${k}</span><span class="stat-val">${v}</span></div>`).join('');
}

function renderFinding(id, p, text) {
    const el = document.getElementById(id);
    if (!el) return;
    const cls = p > 0.10 ? 'finding-ok' : p > 0.01 ? 'finding-warn' : 'finding-fail';
    el.innerHTML = `<div class="finding ${cls}">${text}</div>`;
}

function setBadge(id, p) {
    const el = document.getElementById(id);
    if (!el) return;
    if (p > 0.10) { el.textContent = 'COMPATIBLE'; el.className = 'badge bg-pass'; }
    else if (p > 0.01) { el.textContent = 'DISCREPANTE'; el.className = 'badge bg-warn'; }
    else { el.textContent = 'ANOMAL√çA'; el.className = 'badge bg-fail'; }
}

function buildSummaryHTML(data, info, mu, sigma, dec, n) {
    const m = mean(data), s = sd(data), med = median(data);
    const zMean = (m - mu) / (sigma / Math.sqrt(n));
    return `
        <table class="stats-table" style="width:100%;border-collapse:collapse;font-size:0.83rem;">
            <tr><td style="padding:4px 8px;border-bottom:1px solid #f0f0f0;color:var(--text-secondary);width:55%">Variable</td><td style="padding:4px 8px;border-bottom:1px solid #f0f0f0;text-align:right;font-family:var(--mono)">${info.name} ${info.unit ? '('+info.unit+')' : ''}</td></tr>
            <tr><td style="padding:4px 8px;border-bottom:1px solid #f0f0f0;color:var(--text-secondary)">N</td><td style="padding:4px 8px;border-bottom:1px solid #f0f0f0;text-align:right;font-family:var(--mono)">${n}</td></tr>
            <tr><td style="padding:4px 8px;border-bottom:1px solid #f0f0f0;color:var(--text-secondary)">Media ¬± DE (observada)</td><td style="padding:4px 8px;border-bottom:1px solid #f0f0f0;text-align:right;font-family:var(--mono)">${m.toFixed(2)} ¬± ${s.toFixed(2)}</td></tr>
            <tr><td style="padding:4px 8px;border-bottom:1px solid #f0f0f0;color:var(--text-secondary)">Mediana</td><td style="padding:4px 8px;border-bottom:1px solid #f0f0f0;text-align:right;font-family:var(--mono)">${med.toFixed(2)}</td></tr>
            <tr><td style="padding:4px 8px;border-bottom:1px solid #f0f0f0;color:var(--text-secondary)">Rango</td><td style="padding:4px 8px;border-bottom:1px solid #f0f0f0;text-align:right;font-family:var(--mono)">${Math.min(...data).toFixed(dec)} ‚Äî ${Math.max(...data).toFixed(dec)}</td></tr>
            <tr style="border-top:2px solid var(--border)"><td style="padding:4px 8px;border-bottom:1px solid #f0f0f0;color:var(--text-secondary)"><strong>Referencia Œº ¬± œÉ</strong></td><td style="padding:4px 8px;border-bottom:1px solid #f0f0f0;text-align:right;font-family:var(--mono)"><strong>${mu} ¬± ${sigma}</strong></td></tr>
            <tr><td style="padding:4px 8px;border-bottom:1px solid #f0f0f0;color:var(--text-secondary)">Z de la media</td><td style="padding:4px 8px;border-bottom:1px solid #f0f0f0;text-align:right;font-family:var(--mono)">${zMean.toFixed(2)}</td></tr>
            <tr><td style="padding:4px 8px;color:var(--text-secondary)">Resoluci√≥n</td><td style="padding:4px 8px;text-align:right;font-family:var(--mono)">${dec} decimal${dec!==1?'es':''}</td></tr>
        </table>
    `;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  REPORT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function buildReport(tests, fisherX2, fisherDF, fisherP, nSig, data, info, mu, sigma, n, nSim) {
    const rp = document.getElementById('reportPanel');
    rp.style.display = 'block';
    document.getElementById('rptDate').textContent = new Date().toLocaleString('es-ES');
    document.getElementById('rptNSim').textContent = nSim.toLocaleString();

    let rows = tests.map(t => {
        const status = t.p > 0.10 ? '‚úÖ Compatible' : t.p > 0.01 ? '‚ö†Ô∏è Discrepante' : '‚ùå Anomal√≠a';
        return `<tr>
            <td>${t.name}</td>
            <td style="text-align:center">${formatP(t.p)}</td>
            <td style="text-align:center">${status}</td>
            <td style="text-align:center;font-size:0.75rem;color:var(--text-secondary)">${t.weight}</td>
        </tr>`;
    }).join('');

    const overallStatus = fisherP > 0.10 ? '‚úÖ Compatible' : fisherP > 0.01 ? '‚ö†Ô∏è Discrepante' : '‚ùå Anomal√≠a significativa';

    document.getElementById('reportBody').innerHTML = `
        <table class="report-table">
            <thead>
                <tr>
                    <th>Prueba</th>
                    <th style="text-align:center">p-valor (MC)</th>
                    <th style="text-align:center">Resultado</th>
                    <th style="text-align:center">Nota</th>
                </tr>
            </thead>
            <tbody>${rows}</tbody>
            <tfoot>
                <tr>
                    <td><strong>Test √≥mnibus de Fisher</strong></td>
                    <td style="text-align:center"><strong>${formatP(fisherP)}</strong></td>
                    <td style="text-align:center"><strong>${overallStatus}</strong></td>
                    <td style="text-align:center;font-size:0.75rem">œá¬≤=${fisherX2.toFixed(1)}, gl=${fisherDF}</td>
                </tr>
            </tfoot>
        </table>
        <p style="font-size:0.82rem; margin-top:0.5rem;">
            <strong>Resumen:</strong> De 9 pruebas aplicadas, ${nSig} presentan p-valor < 0.05.
            La prueba combinada de Fisher arroja œá¬≤ = ${fisherX2.toFixed(1)} con ${fisherDF} grados de libertad
            (p = ${formatP(fisherP)}), evaluada contra la distribuci√≥n de referencia N(${mu}, ${sigma}¬≤)
            con ${n} observaciones y ${nSim.toLocaleString()} simulaciones Monte Carlo.
        </p>
    `;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  TOGGLE METHOD
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function toggleMethod() {
    const b = document.getElementById('mBody');
    b.classList.toggle('open');
    document.getElementById('mArrow').textContent = b.classList.contains('open') ? '‚ñ≤' : '‚ñº';
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  INIT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
window.addEventListener('load', () => generateData('real'));
</script>
</body>
</html>